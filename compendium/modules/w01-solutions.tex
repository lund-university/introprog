%!TEX encoding = UTF-8 Unicode
%!TEX root = ../solutions.tex

\ExerciseSolution{\ExeWeekONE}

\BasicTasks %%%%%%%%%%%

\Task % uppgift 1

\Subtask skriver ut \code{"hejsan REPL"}

\Subtask man får fortsätta skriva på nästa rad

\Subtask värde: \code{gurkatomat}, typ:  \code{String}

\Subtask värde: \code{gurkatomatgurkatomatgurkatomatgurkatomat}, typ: \code{String}

% uppgift 2
\Task En literal anger ett specifikt datavärde.
 
\Task % uppgift 3

\Subtask  \code{Int}

\Subtask  \code{Long}

\Subtask  \code{char}

\Subtask  \code{String}

\Subtask  \code{Double}

\Subtask  \code{Double}

\Subtask  \code{Double}

\Subtask  \code{Float}

\Subtask  \code{Float}

\Subtask  \code{Boolean}

\Subtask  \code{Boolean}

% uppgift 4 
\Task  
\begin{REPLnonum}
hejsan
42
gurka
\end{REPLnonum}
\begin{itemize}[noitemsep,nolistsep]
\item Klammerparenteser används för att gruppera flera satser. Klammerparenteser behövs om man vill definiera en funktion som består av mer än en sats. 

\item Semikolon avskiljer flera satser. Semikolon behövs om man vill skriva många satser på samma rad.
\end{itemize}
\Task % uppgift 5

\Subtask  Ett utryck kan evalueras och resulterar då i ett användbart värde. En sats \emph{gör} något (t.ex. skriver ut något), men resulterat inte i något användbart värde.

\Subtask \code{println()}

\Subtask 

 Värdesaknas innehåller Unit

 Skriver ut \code{Unit}

 Skriver ut \code{"()"}

 Skriver ut \code{"()"}

 Skriver först ut hej med det innersta anropet och sen \code{()} med det yttre anropet

\Subtask  \code{Unit}

\Subtask  \code{Unit}

\Task % uppgift 6

\Subtask  \code{Int, 42}

\Subtask \code{Float,19}

\Subtask \code{Double,42}

\Subtask \code{Double,42}

\Subtask \code{Float,1.042E42}

\Subtask \code{Long, 12E6}

\Subtask \code{String, gurka}

\Subtask \code{Char, 'A'}

\Subtask \code{Int,65}

\Subtask \code{Int,48}

\Subtask \code{Int,49}

\Subtask \code{Int,57}

\Subtask \code{Int, 113}

\Subtask \code{ Char, 'q'}

\Subtask \code{ Char, '*'}

\Task % uppgift 7

\Subtask \code{Int, 84}

\Subtask \code{Float, 21}

\Subtask \code{Float, 41.8}

\Subtask \code{Double, 12}

\Task % uppgift 8

\Subtask \code{Int,27}

\Subtask \code{Int,50}

\Subtask \code{Double, 13.3}

\Subtask \code{Int, 13}

\Task % uppgift 9

\Subtask  \code{Int, 21}

\Subtask  \code{Int, 10}

\Subtask \code{Float,10.5}

\Subtask \code{Int, 0}

\Subtask \code{Int, 1}

\Subtask \code{Int,3}

\Subtask \code{Int, 0}

\Subtask \code{((5793 - 1000 * (5793 / 1000)) / 100}


\Task % uppgift 10

\Subtask 127,-128

\Subtask 32767, -32768

\Subtask 2147483647,-2147483648

\Subtask 9223372036854775807,-9223372036854775808

\Task % uppgift 11

\Subtask 
java: PI scala: Pi

\Subtask andvänder sig utav pythagoras sats

\Subtask \code{scalb()}

\Task % uppgift 12

\Subtask den blir \code{Int.MinValue}

\Subtask kastar exeption

\Subtask \code{1.0000000000000001E8}

\Subtask avrundas till \code{1E8}

\Subtask \code{45.00000000000001}

\Subtask returnerar en double som är oändlig

\Subtask \code{Int.MaxValue}

\Subtask \code{NaN}

\Subtask \code{NaN}

\Subtask Man kastar ett nytt exception.

\Task % uppgift 13

\Subtask \code{true}

\Subtask \code{false}

\Subtask \code{false}

\Subtask \code{false}

\Subtask \code{true}

\Subtask \code{true}

\Subtask \code{true}

\Subtask \code{false}

\Subtask \code{true}

\Subtask \code{false}

\Subtask \code{false}

\Subtask \code{true}

\Subtask \code{true}

\Subtask \code{false}

\Subtask \code{true}

\Subtask \code{true}

\Subtask \code{true}

\Subtask \code{false}

\Subtask \code{true}

\Subtask \code{false}

\Subtask \code{true}

\Subtask \code{true}

\Task % uppgift 14

\code{a = 13}

\code{b = 14}

\code{c = Double 54}

\code{b = 0}

\code{a = 0}

\code{c = Double 55}


\Task % uppgift 15

\Subtask 

x blir 30

x blir 31

skriv ut x

x = 32

skriv ut x

false

constant värde y blir 20

fungerar ej

skriv ut gurka och z blir 10

funktionen w blir det inom måsvingarna

skriv ut z

skriv ut z

z blir 11

anropa w

anropa w

fungerar ej

\Subtask  Rad 8 och 16. y är konstant och kan ej modifieras. kan ej modifiera en funktion

\Subtask 
\begin{itemize}[noitemsep, nolistsep]
\item \code{var} används för att deklarera en variabel som kan tilldelas nya värden efter att den initialiserats
\item \code{val} används för att deklarera en variabel som kan tilldelas ett endast en gång (initialseras men sedan inte ändras)
\item \code{def} används för att deklarera en funktion som evalueras varje gång den anropas.
\end{itemize}

\Subtask \code{val even = n % 2 == 0}

\Subtask \code{val odd = n % 2 != 0}

\Task % uppgift 16

a blir 40

b blir 80

a blir 50

b blir 70

a blir 160

b blir 35

\Task % uppgift 17

\Subtask 
\begin{REPLnonum}
Namnet 'Kim Finkodare' har 12 bokstäver.
Efternamnet 'Finkodare' har 9 bokstäver. 
\end{REPLnonum}

\Subtask

\begin{REPLnonum}
val fTot = f.size
val eTot = e.size
println(s"$f har  $fTot bokstäver.")
println(s"$e har  $eTot bokstäver.")
\end{REPLnonum}

\Task % uppgift 18
\begin{enumerate}[nolistsep,noitemsep]
\item skriver ut ''sant'' (else-grenen görs ej)
\item skriver ut ''falskt'' (else-grenen görs)
\item skriver ut ''faskt'' (else-grenen görs)
\item skriver ut ''sant'' (else-grenen görs ej)
\item definerar en funktion som ...
\item ... skriver ut antingen krona eller klave med lika stor sannolikhet
\item singlar slant tre gånger
\end{enumerate}

\Task % uppgift 19

\Subtask \code{String}, inte gott

\Subtask \code{String}, gott

\Subtask \code{String}, likastora

\Subtask \code{String}, gurka

\Subtask \code{String}, banan

\Task % uppgift 20

\Subtask 

1, 2, 3, 4, 5, 6, 7, 8, 9, 10,

1, 2, 3, 4, 5, 6, 7, 8, 9,

2, 4, 6, 8, 10,

1, 11, 21, 31, 41, 51, 61, 71, 81, 91,

1, 2, 3, 4, 5, 6, 7, 8, 9, 10

\Subtask 

\begin{REPLnonum}
scala> for(i <- 1 to 43 by 3) print("A" + i + ", ")
\end{REPLnonum}

\Task % uppgift 21

\Subtask 

9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,

1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,

0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33,

\Subtask 

B33, B30, B27, B24, B21, B18, B15, B12, B9, B6, B3, B0,

\Task % uppgift 22

\Subtask 

0 till 9
0, 2, 4, 6, 8, 10, 12

\Subtask 

\begin{REPLnonum}
var k = 0
while(k <= 43)
{
print("A" + k + ", ")
k = k + 3
}
\end{REPLnonum}

\Subtask \code{foreach}

\Task % uppgift 23

\Subtask  \code{Double}

\Subtask  0, less than 1.0

\Subtask  Nej

\Subtask Man får 20 olika slumptal mellan 1 och 3 då \code{math.random} ger ett slumptal av typen \code{Double} mellan \code{0.0} och nästan, men inte inklusive, \code{1.0}. Om man multiplicerar med $3$ och adderar $1$ och anropar \code{toInt} så blir det ett heltal i intervallet $[1, 3]$.    

\Subtask \code{for for (i <- 1 to 100) println((math.random * 9).toInt)}

\Subtask \code{for (i <- 1 to 100) println((math.random * 5 + 1).toInt)}

\Subtask \code{for (i <- 1 to 100) println((math.random * 6).toInt + 1 )}

\Subtask  gurka skrivs ut olika antal gånger

\Subtask \code{while (math.random > 0.01) println("gurka")}

\Subtask  Samma sak som i dem förra fast man skriver ut slumptalet

\Task % uppgift 24

\Subtask \code{poäng > 1000}

\Subtask\code{poäng > 100}

\Subtask \code{poäng < highscore}

\Subtask\code{poäng < 0 || poäng > highscore }

\Subtask \code{poäng > 0 \&\& poäng < highscore}

\Subtask \code{klar}

\Subtask \code{!klar}




\ExtraTasks %%%%%%%%%%%%

\Task % uppgift 25

\Subtask 
\begin{REPLnonum}
def tärning = (math.random * 6 + 1).toInt
\end{REPLnonum}

\Subtask
\begin{REPLnonum}
def rnd = math.round(math.random * 10) / 10.0f
\end{REPLnonum}

\Subtask
Talen avrundas neråt istället för till närmsta tal vilket gör att det är omöjligt att slumpa fram \code{1.0}

\Task % uppgift 26

\Task % Uppgift 27

\begin{Code}
if (x != 42)  println(":(") else println("the meaning of it all")
\end{Code}

\Task % uppgift 28

\Task % uppgift 29

\begin{Code}
println("My heart will go on")
while(true)  println("and on")
\end{Code}

\Task % uppgift 30

\AdvancedTasks %%%%%%%%%

\Task % Uppgift 31
Scala använder sig utav "Remainder" det vill säga resten vi heltals division. Detta gör att -3 % 4 blir -3 och inte 1 som det blir i matematiken.

\Task % Uppgift 32

\Subtask
Variabeln får namnet "konstig val", backtick gör att man kan namge variabler till annars otilåtna namn t.ex. med mellanrum eller nyckelord i sig.
 
\Subtask
Backticks tillåter en att anropa metoder som heter samma som nyckelord i scala. I java får man döpa en metod till t.ex. yield men ska man anropa metoden i scala krävs då backticks för att yield är ett nyckel ord. java.Thread.`yield`()

\Task % Uppgift 33
\Subtask
\code{toBinaryString} gör om heltalet till en sträng med ettor och nollor som är den binära versionen utav talet. \code{toHexString} gör sama sak fast till ett hexadecimalt tal.
\Subtask
42

\Task % Uppgift 34

\Task % Uppgift 35
 först blir \code{i 42}. \code{i} blir sedan 43 och multipliceras med 2 och blir 86. Efter den delas med 3 blir den 28 eftersom \code{Int} inte har några decimaler.

\Task % Uppgift 36

\Task % Uppgift 37

\Subtask 
Den första raden returnerar 84. Den andra kastar ett exception.

\Subtask
För att kunna hantera situationer när bydelängden på variabler inte är lång nog för värden.

\Subtask
Overflow är när en variabel inte kan inehålla ett värde då det är för stort och istället  blir ett värde som variabeln egentligen inte ska få.

\Task % Uppgift 38

\Subtask
\code{4.9E-3240}

\Subtask
\code{-1.7976931348623157E308}

\Subtask
\code{4.9E-324}

\Task % Uppgift 39

\Task % Uppgift 40

\begin{Code}
val s = f"Gurkan är $g meter lång"
\end{Code}






