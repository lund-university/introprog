%!TEX encoding = UTF-8 Unicode
%!TEX root = ../compendium.tex

\ExerciseSolution{\ExeWeekTHREE}

%Uppgift 1
\Task 

\Subtask 
\begin{REPLnonum}
def öka(x: Int): Int = x+1
\end{REPLnonum}

\Subtask \code{Int}

\Subtask Kompilatorn försöker lista ut vad för returtyp det är och lägger till det själv.

\Subtask För om det skulle bli error och du förväntar dig en returtyp men får en annan så kan det betyda att du har en bug i programmet. Det gör även programmet mer lättläsligt.

\Subtask När man pratar om parameter menar man variablen som används som indata till funktionen, medans argument är den faktiska indatan. Så i detta fallet så är x parametern, vilket är namnet vi get parametervariablen, medans 42 är argumentet. 

\Subtask \code{46}

\Subtask 
\begin{REPLnonum}
def minska(x: Int): Int = x-1
\end{REPLnonum}

\Subtask \code{42}

%Uppgift 2
\Task 

\Subtask \code{-100}

\Subtask \code{15}

\Subtask \code{185}

\Subtask \code{256}

%Uppgift 3
\Task 
Funktionen lägger helt enkelt ihop två värden och om det andra saknas så lägger den bara på 1 till första värdet, d.v.s. om andra värdet saknas antas det vara 1.

Så det första anropet returnerar 44, det andra 43 och det sista returnerar även det 43 då j antas vara 1.


%Uppgift 4
\Task 

\Subtask 
Utskriften blir följande:
\begin{REPLnonum}
Namn: Robinson, Kim
Namn: Oval, Viktor
Namn: Triangelsson, Stina
\end{REPLnonum}
Eftersom vi har namngett argumenten så behöver vi inte nödvändigtvis skriva argumenten i rätt ordning. Att namnge argumenten i andra anropet gör ingen skillnad, men i tredje så skriver vi egentligen in argumenten i fel ordning. 

\Subtask
Det blir lättare att hålla reda på vad som är vad både när man skriver och sedan när man ska läsa koden. Det låter oss även skriva argument i den ordningen som känns naturligast för oss istället för vad funktionen har dikterat.

%Uppgift 5
\Task
Detta är alla olika sätt att köra en funktion över alla element i en samling

\Subtask \code{Vector(1, 2, 3, 4, 5)}

\Subtask \code{Vector(0, 1, 2, 3, 4)}

\Subtask \code{Vector(1, 2, 3, 4, 5)}

\Subtask \code{Vector(0, 1, 2, 3, 4)}

\Subtask \code{Vector(1, 2, 3, 4, 5)}

\Subtask \code{Vector(0, 1, 2, 3, 4)}

\Subtask \code{Vector(13, 4, 42, -7)}

\Subtask \code{Vector(11, 2, 40, -9)}

%Uppgift 6
\Task

\Subtask \code{dallas}

\Subtask \code{dallas}

\Subtask Koden skriver ut \code{dallas} när du sparar variablen för proceduren skriver ut när den anropas, men den returnerar inget så \code{print(x)} skriver inte ut något

\Subtask Det är en procedur så den returnerar inget att skriva ut

\Subtask Det är en procedur så den returnerar inget att skriva ut

\Subtask Det är en procedur så den returnerar inget att skriva ut

\Subtask För att man ska vara säker på att den faktiskt är en procedur och inte gör något man inte väntat sig. Det är ett bra sätt att bugtesta för ifall det blir ett exception så kanske det finns något fel man borde kolla på.

\Task

\Subtask \code{snark, Int = 42}

\Subtask \code{snark snark snark, Int = 42}

Den evaverar inte uttrycket förrän det behövs så flera snark ger bara ett resultat för det är bara det som begärs

\Subtask \code{2}

\Subtask \code{2}

Det är ingen större skillnad när vi bara skickar in en etta.

\Subtask \code{snark, Int = 84}

\Subtask När vi kallar på \code{callByValue} så skickar vi in snark som ett värde, och därmed behöver x bara beräknas en gång medans när vi kallar på \code{callByName} så skickar vi den som en funktion och därmed kallas snark på två gånger i funktionen för att beräkna x båda gångerna

\code{snark snark, Int = 84}

\Subtask \code{görDetta} är en kontrolstruktur som helt enkelt exekverar koden den matas med, \code{görDettaTvåGånger} gör just vad den säger. Detta är dock grunderna för vad som kan bli mycket mer advancerat om man kombinerar detta med loopar eller if-satser, som i sig är kontrolstrukturer.

%Uppgift 8
\Task Först så adderas 22 och 20 för att bli 42

Sedan adderas först 1 och 19 och det adderas sen med 22 för att tillslut bli 42.

%Uppgift 9
\Task

\Subtask -

\Subtask I den första parameterlistan så anges hur många gånger koden i den andra parameterlistan ska exekveras. så \code{upprepa(10)(println("hej"))} printar hej 10 gånger

%Uppgift 10
\Task

\Subtask Man kan spara en funktion som en variabel och funktioner kan likt andra värden sparade i variabler användas i andra funktioner så länge det är godkänd indata. Så femte raden blir identisk med tredje.

\Subtask Kompilatorn saknar en parameterlista så den kastar ett fel, genom att ange \_ så säger vi åt den att vi tar emot en godtycklig parameter.

\Subtask 
\begin{REPLnonum}
def dec(x: Int): Int = x - 1
val g = dec _
Vector(12, 3, 41, -8).map(g)
\end{REPLnonum}

\Subtask Int => Int

g har samma typ som f alltså  Int => Int

\Subtask d = 84, h = 21. Räkna tar en funktion och ger den det första argumentet som indata.

%Uppgift 11
\Task När man gör curryfunktioner så skjuter man upp att ange det andra värdet till senare och på så sätt gör "nya" funktioner så att säga. När vi sparar undan variablen \code{f} så har vi angett första argumentet men den väntar fortfarande på det andra som vi anger sen vilket ger ett resultatvärde. 

Samma sak senare, genom att skapa variablerna inc och dec som summan av +1 respektive -1 så har vi "skapat" våra \code{inc} och \code{dec} funktioner från tidigare funktioner.

%Uppgift 12
\Task

\Subtask -

\Subtask -

\Subtask 
\begin{REPLnonum}

---- Frekvenser ----
Antal tecken: 1932
Antal ord: 337
Antal meningar: 84

---- Frekvenser ----
Antal tecken: 1890
Antal ord: 295
Antal meningar: 126

---- Frekvenser ----
Antal tecken: 3824
Antal ord: 633
Antal meningar: 210

\end{REPLnonum}

Först och främst, vi har default argument 42 så det är det som används vid anropet. Detta används för att multiplicera \code{s1} och \code{s2} i \code{Test} när man anropar \code{printFreq}. \code{statistics} objektet använder i sin tur funktionerna i \code{stringfun} för att räkna ord och meningar. Resultatet presenteras av \code{statistics}, vilket är det vi ser.

\Subtask vi ser att stringfun är enbart funktioner och har därmed ingt tillstånd.

statistics har ett tillstånd eftersom variablen history sparar vad som skett, så när man anropar funktionener i objektet så kan objektet ändra beteende beroende på dess tillstånd, tillståndet består alltså av history.

%Uppgift 13
\Task

\Subtask inc, addY och isPalindrome. Notera att y sätts till x's värde i början vilket är 0 och sedan kan det inte ändras eftersom det är en \code{val}.

\Subtask Försök att med samma argument få olika resultat med samma funktion genom att ändra x

\Subtask Vad är x och y?

\Subtask y

%Uppgift 14
\Task

\Subtask
Först notera att \code{plus} med bara paranteser och med \code{apply} är indentiska anrop, för det är det som är tricket med ett object med \code{apply} metod man kan kalla på den som en funktion.

Sedan sparar vi en funktion som add, men eftersom alla fukntioner också är object så så har de några andra metoder man också kan anropa vilket vi ser med TAB. 

Till sist så sparar vi en ny funktion inc som en curry funktion av add med 1 som argument.

\Subtask
\begin{REPL}
scala> object slumptal{ def apply(a: Int, b: Int) = (math.random * b + a).toInt }
defined object slumptal

scala> (1 to 100).foreach{i => print(slumptal.apply(1,6) + " ")}
3 5 6 6 5 3 4 3 2 3 1 3 1 2 2 5 1 2 6 2 1 1 4 5 5 3 4 6 5 1 1 2 3 1 1 1 4 4 6 1 1 6 3 3 1 4 3 4 2 3 4 4 1 2 5 6 1 6 4 2 5 3 6 1 6 5 1 1 1 3 4 3 5 5 3 6 6 4 4 1 2 5 6 5 5 1 1 2 6 1 6 4 6 3 5 5 2 2 3 3 
scala> (1 to 100).foreach{i => print(slumptal(1,6) + " ")}
4 2 1 6 5 2 5 2 2 3 1 3 3 3 5 1 6 1 1 2 2 2 2 2 3 6 1 5 6 4 2 3 3 2 2 4 1 5 4 6 4 5 6 2 4 4 3 4 3 3 3 1 3 2 6 4 3 6 4 2 6 6 3 1 1 3 4 3 6 1 4 4 4 5 5 2 5 2 4 2 5 2 1 4 1 5 4 3 1 2 3 6 3 3 5 5 6 6 6 5 

\end{REPL}

%Uppgift 15
\Task

\Subtask Notera vid deklarationen av \code{nu}, \code{sen} och \code{igen} så är det bara \code{nu} som tar tid och skriver ut sin text. För \code{nu} evalueras men de andra väntar.

Men när vi ska kalla på dem så tar \code{nu} ingen tid och skriver inte ut nu medans \code{sen} och \code{igen} nu tar tid och skriver ut sin text. För \code{nu} har redan evaluerats men de andra behöver evalueras för de kallas på.  

Och när vi kallar på dem för andra gången så är det bara \code{igen} som tar tid. För \code{nu} och \code{sen} är evaluerade och vid det här laget identiska medans \code{igen} behöver evalueras varje gång man kallar på den.

Vid deklaration av objektet så går allt bra, när vi kallar på \code{liten} så får vi 42 men när vi kallar på \code{stor} så får vi exception. Eftersom objekt är lata så evalueras inte objektet förrän vi anropar något ur det men \code{stor} är också lazy så den blir inte ett problem förrän just den anropas.

\Subtask
\code{val} evalueras direkt, \code{lazy val} evalueras när det behövs medans \code{def} evalueras varje gång det behövs.

\Subtask
När vi skapar objektÄrLata så skrivs inget ut för det evalueras inte förrän vi kallar på det, som vi gör nästa rad då skrivs nu ut. När vi sedan anropar sen evalueras inget och nu skrivs inte ut.

\{\code{val x=y; val y = 42}\} kastar error eftersom y inte är evaluerad när vi försöker evaluera x.

När vi skapar \code{buggig} så varnar den och vi ser varför på nästa rad då att \code{a} verkar vara lika med 0. Eftersom \code{b} inte är evaluerad än så blir det 0 men till skillnad från tidigare vet \code{val a} iallafall att den är en Int eftersom objectet med \code{b} är åtminstone definerat.

\code{funkar} fungerar just för att \code{a} är en \code{lazy val} och evalueras då inte förrän efter \code{b} evaluerats och ger därför 42 som den ska.

\code{nowarning} har samma problem som \code{buggig} men ger ingen varning och därför försöker skriva ut innan \code{one} är evaluerad och ger därför nollor.

\Subtask 
När man vill skapa ett objekt som funkar eller fixa problemet i no warning, man kan vilja ha sina variabler i just den ordningen p.g.a. läslighet.

Men även om man inte vill slöa ner ett system med en massa arbete när allt deklareras på en gång utan tar det hellre gradvis allteftersom det används. 

%Uppgift 16
\Task

\Subtask
Utskrift: \\
inc[x = 0]\\
dec[x = 1]\\
inc[x = 0]\\
1\\ 

\code{inc} kallar på \code{dec} som i sin tur kallar på \code{inc} med argumentet 0. den sista funktionen returnerar sedan 1 varpå nästa minskar till 0 och den sista ökar till 1.

add[x = 1, y = -2]\\
dec[x = 1]\\
dec[x = 0]\\
add[x = 1, y = -1]\\
dec[x = 1]\\
add[x = 1, y = 0]\\
1\\

\code{add} kallas på tre gånger, \code{add} längst ner kallar på \code{dec} två gånger på varandra för att returnera -1 till andra \code{inc} som tar det som argument.

Den andra \code{add} kallar på \code{dec} en gång och returnerar 0 till första \code{add}

Den ursprungliga \code{add} returnerar till sist 1 utan att kalla på några andra funktioner
  
\Subtask
Stacken för \code{x} när den är som djupast

\begin{tabular}{|c|}
\hline
inc \\
\hline
dec\\
\hline
inc \\
\hline
\end{tabular}
\\
\\
När vi har nått tredje add och den kallat på dec så ser den ut så här för två iterationer. 
\\
\\
\begin{tabular}{|c|}

\hline
dec \\
\hline
add \\
\hline
add\\
\hline
add \\
\hline
\end{tabular}
\\
\\
Sedan vid det andra add så ser den ut så här i en iteration varpå den sedan rensas
\\
\\
\begin{tabular}{|c|}

\hline
dec \\
\hline
add \\
\hline
add\\
\hline
\end{tabular}

%Uppgift 17
\Task

\Subtask
1\\
add[x = 1, y = -2]\\
dec[x = 1]\\
dec[x = 0]\\
add[x = 1, y = -1]\\
dec[x = 1]\\
add[x = 1, y = 0]\\
1\\
Vi saknar utskrift när den arbetar med \code{x} för den använder de funktioner som den känner till vilket är de versioner utan utskrift, när vi kallar på \code{add} så får vi dock utskrift när vi kallar på \code{inc} samt \code{dec} för add använder sin lokala variant.

\Subtask
Den stora fördelen är att man kan separera kod i funktioner lokalt utan att påverka något utanför och därmed göra sin kod mer lättläst. Det kommer även dock till stor nytta ifall man vill ha annan funktionalitet lokalt än allmänt, då kan man definera en ny lokal funktion med samma namn som gör något lite anorlunda.

%Uppgift 18
\Task

\Subtask
\code{Vector(2, 3, 4, 5} Lägger till 1 på varje\\
\code{Vector(2, 3, 4, 5} Identisk med ovan\\
\code{Vector(2.0, 4.0, 8.0, 16.0} Ger 2 upphöjt med talen från vektorn\\
\code{Vector(1.0, 4.0, 9.0, 16.0} Talen upphöjt med 2\\
\code{Vector(1, 2, 3, 4} Skriver ut talen som sträng\\
\code{Vector(1, 2, 3, 4} Identisk med ovan\\

\Subtask
Int => Int 
Int => Int
Int => Double
Int => Double
Int => String
Int => String \\
Den vet vad den behöver utgå ifrån och på samma sätt som man i vanliga fall inte explicit behöver ange returtyp för funktioner i scala så ser den vad för typ som returneras t.ex. \code{i.toString} returnerar en String

\Subtask
Missing Parameter type och Missing Parameter type for expanded function

%Uppgift 19
\Task

\Subtask
\code{countdown} skriver ut x och kallar på \code{countdown} igen med x-1 som argument om det är större än noll vilket innebär att samma sak görs igen tills x når 0.

\code{finalCountdown} gör samma sak fast med en Byte och den fortsätter även om x passerar 0 med de rekursiva funktionsanropen.

\Subtask
Eftersom vi hade \code{1/x} efter rekursionsanropet innan så kom vi aldrig dit för vi returnerade aldrig något utan gick bara djupare i stacken. Om vi placerar \code{1/x} tidigare så når vi den raden kod och den kastar ett exception då det är division med noll.

\Subtask
Den sista raden leder till mycket fler rekursiva anrop, för rekursionen avslutas när y är noll, inte om x är det.






