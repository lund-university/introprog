
%!TEX encoding = UTF-8 Unicode
%!TEX root = ../exercises.tex

\ifPreSolution

\Exercise{\ExeWeekELEVEN}\label{exe:W11}

\begin{Goals}
\item Kunna förklara vad en kontextparameter är. 
\item Kunna förklara nyttan med kontextparametrar jämfört med en globala variabler och defaultargument vid lösning av konfigurationsproblemet.
%\item Känna till hur givna sorteringsordningar används för egendefinierade typer.
\item Kunna använda enkla kontextuella abstraktioner med \code{given} och \code{using}.
%\item Känna till existensen av, funktionen hos, och relationen mellan klasserna \code{Ordering} och \code{Comparator}, samt  \code{Ordered} och \code{Comparable}.

\end{Goals}

\begin{Preparations}
\item \StudyTheory{11}
\end{Preparations}

\BasicTasks %%%%%%%%%%%%%%%%

\else

\ExerciseSolution{\ExeWeekELEVEN}

\BasicTasks %%%%%%%%%%%

\fi

\WHAT{Kontextparameter.}

\QUESTBEGIN

\Task  \what~Deklarera följande funktioner som tar ett heltal som kontextparameter. Skapa även en \code{given}-deklaration som erbjuder det givna heltalsvärdet noll:
\begin{REPLnonum}
scala> def f(using i: Int) = i + 1

scala> def g(x: Int)(using y: Int) = x + y
\end{REPLnonum}

\Subtask Anropa funktionerna \code{f} och \code{g} med ett explicit givet argument som skiljer sig från det givna heltalsvärdet med hjälp av \code{using} i anropet. Vad händer om du utelämnar \code{using}?

\Subtask Anropa funktionerna \code{f} och \code{g} utan att ange \code{using}-argument. Förklara vad som händer. 

\Subtask Går det att blanda vanliga parametrar och kontextparametrar i samma parameterlista? Om inte vad händer?

\SOLUTION

\TaskSolved \what

\SubtaskSolved
\begin{REPLnonum}
scala> given Int = 0
val res0: Int = 83

scala> f(using 41)
val res1: Int = 42

scala> g(41)(using 42)
val res2: Int = 83
\end{REPLnonum}
\noindent 
Om man glömmer \code{using} vid explicit kontextargument blir det kompileringsfel. Kompilatorn blir ''förvirrad'' och tror att du försöker ge ett ''vanligt'' argument till en (i detta fallet) icke-existerande ''vanlig'' parameterlista.  
\begin{REPLnonum}
scala> f(41)
-- [E050] Type Error: ----------------------------------------------
1 |f(41)
  |^
  |method f does not take more parameters
  |
  | longer explanation available when compiling with `-explain`
1 error found

scala> :setting -explain

scala> f(41)
-- [E050] Type Error: ----------------------------------------------
1 |f(41)
  |^
  |method f does not take more parameters
  |-----------------------------------------------------------------
    | Explanation (enabled by `-explain`)
  |- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  | You have specified more parameter lists than defined in the 
    method definition(s).
   -----------------------------------------------------------------

scala> g(41)(42)
-- [E050] Type Error: ----------------------------------------------
1 |g(41)(42)
  |^^^^^
  |method g does not take more parameters
  |-----------------------------------------------------------------
    | Explanation (enabled by `-explain`)
  |- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  | You have specified more parameter lists than defined in the 
    method definition(s).
   -----------------------------------------------------------------
\end{REPLnonum}
Det är inte vanligt att ange \code{using}-parametrar explicit; det vanligaste är att låta kompilatorn framkalla ett givet värde.

\SubtaskSolved Det givna värdet \code{0} binds till motsvarande kontextparameter, som ska vara deklarerad i en egen parameterlista som börjar med \code{using}.
\begin{REPLnonum}
scala> f
val res3: Int = 1

scala> g(42)
val res4: Int = 42
\end{REPLnonum}

\SubtaskSolved Nej, det blir kompileringsfel om man försöker blanda vanliga parametrar och kontextparametrar i en och samma parameterlista:
\begin{REPLnonum}
scala> def h(i: Int, using j: Int) = i + j
-- [E040] Syntax Error: ---------------------------------------------
1 |def h(i: Int, using j: Int) = i + j
  |                    ^
  |                    ':' expected, but identifier found
\end{REPLnonum}
Det är ett medvetet val att kräva separata parameterlistor, så att det inte ska uppstå förvirring om huruvida en vanlig parameter eller kontextparameter avses. 

\QUESTEND



\WHAT{Flera olika givna värden i lokal kontext.}

\QUESTBEGIN

\Task \what~Olika värden beroende på kontext.
\begin{Code}
case class Delta(value: Int)
object Delta:
  given default: Delta = Delta(1)

def inc(x: Int)(using dx: Delta) = x + dx.value

object Context1:
  val a = inc(1)

object Context2:
  given Delta = Delta(42)
  val a = inc(1)

\end{Code}

\Subtask Vilket värde har \code{Context1.a}? 

\Subtask Vilket värde har \code{Context2.a}? 

\Subtask Förklara vad som händer.

\SOLUTION

\TaskSolved \what

\SubtaskSolved 2

\SubtaskSolved 43

\SubtaskSolved När kompilatorn försöker framkalla ett givet värde att automatiskt använda som argument till \code{using}-parametern \code{dx}, så letar den i den kontext som är närmast anropet först. Om det finns ett givet värdet i kompanjonsobjektet för parametertypen så tar kompilatorn detta i sista hand, om inget annat givet värde hittas närmare anropet.

\QUESTEND




\WHAT{Lösning på konfigurationsproblemet med hjälp av givna värden.}

\QUESTBEGIN

\Task  \what~ Antag att vi vill kunna konfigurera beteendet hos en funktion för att göra den mer flexibel. Nedan visas tre principiellt olika sätt att göra detta på för en funktion \code{greet} som skriver ut en hälsning: 1) en globalt åtkomlig variabel, 2) defaultargument, samt 3) kontextuell abstraktion med \code{given} och \code{using}.

\begin{Code}
object GlobalVar:
  case class GreetConfig(greeting: String, receiver: String)
  object GreetConfig:
    val default = GreetConfig(greeting = "Hello", receiver = "World")
    var config = default
  
  def greetMsg = 
    s"${GreetConfig.config.greeting} ${GreetConfig.config.receiver}!"

object DefaultArgs:
  case class GreetConfig(greeting: String, receiver: String)
  object GreetConfig:
    val default = GreetConfig(greeting = "Hello", receiver = "World")
  
  def greetMsg(config: GreetConfig = GreetConfig.default) =
    s"${config.greeting} ${config.receiver}!"

object GivenVal:
  case class GreetConfig(greeting: String, receiver: String)
  object GreetConfig:
    given default: GreetConfig = GreetConfig("Hello", "World")
  
  def greetMsg(using g: GreetConfig) = s"${g.greeting} ${g.receiver}"
\end{Code}

\Subtask Skriv kod som testar de olika varianterna ovan. Visa speciellt hur du kan använda default-konfigurationen och därefter ge en konfiguration som skiljer sig från \code{default}. 

\Subtask Vad är för- och nackdelar med de olika varianterna ovan? Diskutera speciellt vilken/vilka lösningar som medger flera lokala konfigurationer utan att de påverkar varandra.

\Subtask Förklara vad som händer vid anrop av \code{summon[GivenVal.GreetConfig]}. 

\Subtask Vad händer om du försöker framkalla ett givet värde för en typ som inte har något sådant?

\Subtask Måste det givna värdet vara unikt?

\SOLUTION


\TaskSolved \what\\

\noindent Nedan visas test av de tre olika lösningarna som givits i uppg. \SubtaskSolved

\noindent Efter varje test diskuteras tillhörande för- och nackdelar, som efterfrågas i uppg. \SubtaskSolved

\begin{Code}
def testGlobalVar(useDefault: Boolean = true) = 
  import GlobalVar.*
  if useDefault then println(greetMsg) else 
    GreetConfig.config = GreetConfig("Godmorgon", "världen")
    println(greetMsg)
\end{Code}
Eftersom \code{config} här är en förändringsbar variabel, så kan en ändring på ett ställe påverka helt andra delar av programmet, vilket ibland kan vara en fördel, men ofta en nackdelen eftersom det kan vara svårt att förstå vad som händer bara genom att läsa en enskild del av programmet -- en förändring av \code{config} kan ju ske varsomhelst. Det är lätt att glömma ändra till baka till default-värdet, om det är det som förväntas.
\begin{REPL}
scala> testGlobalVar(); testGlobalVar(false); testGlobalVar()
Hello World!
Godmorgon världen!
Godmorgon världen!
\end{REPL}

\begin{Code}[numbers=left]
def testDefaultArgs(useDefault: Boolean = true) =
  import DefaultArgs.*
  if useDefault then println(greetMsg()) else 
    println(greetMsg(GreetConfig("Godmorgon","världen")))
\end{Code}
Här sker ingen tillståndsförändring och default-användning är enkel, men det går inte enkelt att göra avsteg från default som  gäller i en lokal kontext; vid \emph{varje} enskilt anrop behöver du explicit ange alla de argument som inte ska vara default, så som visas på rad 4 ovan. Ändring av default har bara lokal påverkan. Om alla argument ska följa default, så gäller det att inte glömma anropa med tomt parentespar: \code{greetMsg()}. (Vad händer annars?)
\begin{REPL}
scala> testDefaultArgs(); testDefaultArgs(false); testDefaultArgs()
Hello World!
Godmorgon världen!
Hello World!
\end{REPL}
Med kontextparametrar är flexibiliteten större; \code{using}-parametrar låter användaren själv styra vad som gäller i olika sammanhang och själva anropet blir enkelt oavsett om det är default-värdet eller andra, i den lokala kontexten, givna värden som önskas. Ändring av default har bara lokal påverkan, men den har påverkan på godtyckligt många anrop i den lokala kontexten --  argument som skiljer sig kan alltså vara givna en gång utan att behöva upprepas vid varje anrop. Vid anrop där man vill låta kompilatorn framkallar givna värden för kontextparametern ska inga parenteser användas, och anropen bli därmed korta och enkla.
\begin{Code}
def testGivenVal(using g: GivenVal.GreetConfig) = println(g.greetMsg)
\end{Code}

\begin{REPL}
scala> testGivenVal
Hello World

scala> def localContext =
         import GivenVal.*
         given GreetConfig = GreetConfig("Godmorgon","världen")
         testGivenVal

scala> localContext
Godmorgon världen

scala> testGivenVal
Hello World
\end{REPL}


\SubtaskSolved  Kompilatorn framkallar ett givet värde i den lokala kontexten:
\begin{REPL}
scala> summon[GivenVal.GreetConfig]
val res0: GivenVal.GreetConfig = GreetConfig(Hello,World)
\end{REPL}
Kompilatorn följer denna prioritetsordning i sökandet efter ett unikt givet värde:
\begin{enumerate}[nolistsep,noitemsep]
\item \textbf{Explicita} argument till kontextparametrar märkta med \code{using}
\item \code{given} och \code{import given ...} i aktuell namnrymd \Eng{current scope} 
\item \code{given}-värden i \textbf{kompanjonsobjekt} för den använda typen.
\end{enumerate}
Om flera givna värden kan framkallas för typer som ingår i en gemensam arvshierarki så väljer kompilatorn det givna värdet som är av den \emph{mest specifika} typen.\\

\SubtaskSolved Det blir kompileringsfel om kompilatorn inte hittar ett givet värde för den typ som avses.

\begin{REPL}
scala> summon[Long]
-- Error: ----------------------------------------------------------------
1 |summon[Long]
  |            ^
  |            no given instance of type Long was found for parameter x of 
               method summon in object Predef
1 error found
\end{REPL}

\SubtaskSolved Ja! Det får \emph{inte} vara tvetydigt vilket givet värde som ska framkallas:
\begin{REPL}
scala> def tvetydigt =
     |   given a: Int = 42
     |   given b: Int = 43
     |   summon[Int]
     | 
-- Error: ------------------------------------------------------------------
4 |  summon[Int]
  |             ^
  |ambiguous given instances: both given instance b and given instance a 
  |match type Int of parameter x of method summon in object Predef
1 error found

\end{REPL}
Läs mer om kontexuella abstraktioner här:\\\url{https://docs.scala-lang.org/scala3/reference/contextual/}


\QUESTEND


\ExtraTasks


\WHAT{Kontextparameter och givet värde.}

\QUESTBEGIN

\Task  \what~Prova nedan i REPL.
\begin{REPL}
scala> def add(x: Int)(using y: Int) = x + y
scala> add(1)(using 2)
scala> add(1)
scala> given ngtNamn = 42
scala> add(1)
\end{REPL}
\Subtask Vad blir felmeddelandet på rad 3 ovan? 

\Subtask Varför fungerar det på rad 5 utan fel?

\Subtask Definiera och testa en motsvarande funktion \code{sub} som kan subtrahera ett givet värde.

\SOLUTION


\TaskSolved \what

\SubtaskSolved 
\begin{REPL}
scala> add(1)
-- Error: ------------------------------------------------------------------
1 |add(1)
  |      ^
  |    no given instance of type Int was found for parameter y of method add
1 error found
\end{REPL}

\SubtaskSolved Nu finns ett givet värde som kompilatorn automatiskt kan fylla i på platsen vid anropet.

\SubtaskSolved \code{def sub(x: Int)(using y: Int) = x - y}

\QUESTEND

\AdvancedTasks %%%%%%%%%%%


\WHAT{Varians och typgränser.}

\QUESTBEGIN

\Task  \what~ Koden nedan är en modell av husdjur med följande innebörd: Husdjur kan vara friska eller sjuka och föds i normalfallet friska. Det kan finnas många katter och hundar, vilka alla är olika slags husdjur.

\begin{Code}
trait Pet(var isHealthy: Boolean = true)
class Cat extends Pet()
class Dog extends Pet()

\end{Code}

\Subtask Förändra koden nedan så att efterföljande REPL-sats \emph{inte} ger kompileringsfel?
\begin{Code}
case class Box[A](x: A)
\end{Code}
\begin{REPLnonum}
scala> val b: Box[Any] = Box[Cat](Cat())
\end{REPLnonum}

\Subtask Prova nedan i REPL och förklara vad som händer.      
\begin{REPLnonum}
scala> val v: Vector[Pet] = Vector[Cat](Cat())

scala> val s: Set[Pet] = Set[Cat](Cat())

scala> :settings -explain

scala> val s: Set[Pet] = Set[Cat](Cat())
\end{REPLnonum} 
\emph{Ledtråd:} I Scalas standardbibliotek så är ärver \code{Set[T]} funktionstypen \code{T => Boolean} som är deklarerad kontravariant i sin inparameter.

\Subtask Det ska finnas veterinärer som kan behandla husdjur och göra dem friska. Varför fungerar inte nedan kod? Är det ett kompileringsfel eller körtidsfel?

\begin{Code}
class Vet[-A]:
  def treat(x: A): Unit = x.isHealthy = true
\end{Code}

\Subtask Inför en typgräns i veterinärens typparametern som åtgärdar felet.

\Subtask Skriv valfri kod som visar 1) att kompilatorn tillåter kattveterinärer att behandla katter men 2) förhindrar att kattveterinärer får behandla godtyckliga husdjur och att 3) en veterinär som har komptens att behandla godtyckliga husdjur kan behandla både katter och hundar. Förklara varför kompilatorn tillåter/förhindrar detta.

\SOLUTION


\TaskSolved \what

\SubtaskSolved Gör lådan flexibel i sin typparameter med ett \code{+} före typparametern enligt nedan. 
\begin{Code}
case class Box[+A](x: A)
\end{Code}
Kompilatorn tillämpar reglerna för kovarians eftersom typparametern har ett plustecken framför sig: \code{Box[Cat]} är en suptyp till \code{Box[Any]} om \code{Cat} är en subtyp till \code{Any}, vilket den ju är eftersom alla typer är subtyp till \code{Any}. 

\SubtaskSolved Förklaringen till beteendet har med olika varians att göra:
\begin{itemize}
  \item Samlingen \code{Vector} är kovariant och därmed flexibel i sin typparameter (liksom andra oföränderliga sekvenser i Scalas standardbibliotek). Kompilatorn betraktar därmed \code{Vector[Cat]} som en subtyp till \code{Vector[Pet]} eftersom \code{Cat} är en subtyp till \code{Pet}. På platser i koden där en \code{Vector[Pet]} krävs så anses \code{Vector[Cat]} överensstämma med \Eng{conforms to} \code{Vector[Pet]} och får därmed duga på dessa platser.
  \item En mängd har en apply-metod från elemttypen till \code{Boolean} som ger innehållstest. Av det skälet har man låtit \code{Set[T]} ärva \code{Function1[T, Boolean]} som är deklarerad kontravariant i \code{T}, så att en mängd kan användas där en \code{T => Boolean} förväntas. Även om det skulle vara praktiskt om Set[T] vore kovariant i \code{T}, i likhet med \code{Vector}, \code{List}, \code{Seq} etc, så kan inte \code{T} vara både kovariant och kontravariant på en och samma gång. Man har därför valt att göra \code{Set} invariant och därmed är mängder ej flexibla i sin typparameter. \code{Set[Cat]} är alltså \emph{inte} en subtyp till \code{Set[Pet]} \emph{även} om \code{Cat} är en subtyp till \code{Pet}, vilket ger kompileringsfel i uppgiftens exempel. 
  Se även \url{https://stackoverflow.com/questions/676615/why-is-scalas-immutable-set-not-covariant-in-its-type}  
  \item Med \code{:settings -explain} ger kompilatorn en längre utskrift som förklarar den bevisföring som skedde under kompileringens typkontroll.
\end{itemize}



\SubtaskSolved Det blir kompileringsfel då metoden \code{isHealthy} ej existerar för godtycklig typ.

\SubtaskSolved Lägg till en övre gräns som garanterar att metoden \code{isHealthy} finns för alla typer som kan bindas till typparametern \code{A}:
\begin{Code}
class Vet[-A <: Pet]:
  def treat(x: A): Unit = x.isHealthy = true
\end{Code}
Kompilatorn garanterar alltså att typparametern \code{A} är ''mindre än eller lika med'' \code{Pet}.

\SubtaskSolved Veterinären \code{Vet} är flexibel i sin typparameter och minustecknet anger kontravarians och därmed att \code{Vet[Pet]} är en subtyp till \code{Vet[Cat]} då \code{Cat} är en subtyp till \code{Pet}. Detta kan demonstreras med nedan exempel:
\begin{REPL}
scala> val pinkPanther = Cat()
val pinkPanther: Cat = Cat@33e7ece5

scala> val somePet: Pet = Cat()
val somePet: Pet = Cat@57f1cb96

scala> val catVet = Vet[Cat]()
val catVet: Vet[Cat] = Vet@1060e784

scala> pinkPanther.isHealthy = false

scala> catVet.treat(pinkPanther)

scala> pinkPanther.isHealthy
val res2: Boolean = true

scala> somePet.isHealthy = false

scala> catVet.treat(somePet)
-- [E007] Type Mismatch Error: --------------
1 |catVet.treat(somePet)
  |             ^^^^^^^
  |             Found:    (somePet : Pet)
  |             Required: Cat

scala> val powerVet = Vet[Pet]()
val powerVet: Vet[Pet] = Vet@2eb90ae9

scala> pinkPanther.isHealthy = false

scala> powerVet.treat(pinkPanther)

scala> pinkPanther.isHealthy
val res3: Boolean = true

scala> val pluto = Dog()
val pluto: Dog = Dog@6f27db5d

scala> pluto.isHealthy = false

scala> powerVet.treat(pluto)

scala> pluto.isHealthy
val res4: Boolean = true

\end{REPL}


\QUESTEND




\WHAT{Typklasser och kontextparametrar.}

\QUESTBEGIN

\Task  \what~  I Scala finns möjligheter till avancerad funktionsprogrammering med s.k. \textbf{typklasser} (ä.k. \emph{ad hoc polymorfism}). En typklass definierar generella beteenden som fungerar för godtyckliga befintliga typer utan att implementationen av dessa behöver ändras. Vi nosar i denna uppgift på hur kontextuella abstraktioner kan användas för att skapa typklasser i Scala, illustrerat med hjälp av givna ordningarna vid sortering.

Genom att kombinera koncepten givna värden, generiska klasser och kontextparametrar får man möjligheten till ad hoc polymorfism, exemplifierat med typklassen \code{CanCompare} nedan, som vi kan få att fungera för befintliga typer \emph{utan} att de behöver ändras. Speciellt så har vi ju inte möjligheten att lägga till metoder på befintliga typer i standardbiblioteket, eftersom det inte är våran egen kod.


\Subtask 
Vad händer nedan? Vilka rader ger felmeddelande? Varför?

\begin{REPL}
scala> trait CanCompare[T]:
         def compare(a: T, b: T): Int

scala> def sort[T](a: T, b: T)(using cc: CanCompare[T]): (T, T) =
         if cc.compare(a, b) > 0 then (b, a) else (a, b)

scala> sort(42, 41)

scala> given intComparator: CanCompare[Int] with
         override def compare(a: Int, b: Int): Int = a - b

scala> sort(42, 41)

scala> sort(42.0, 41.0)
\end{REPL}

\Subtask Definiera ett givet värde som gör så att \code{sort} fungerar för värden av typen \code{Double}.

\Subtask Definiera ett givet värde som gör så att \code{sort} fungerar för värden av typen \code{String}. \emph{Tips:} Du har nytta av de befintliga jämförelseoperatorerna på strängar, men tänk på att \code{compare} fortfarande måste returnera ett heltal även vid jämförelse av strängar.


\SOLUTION


\TaskSolved \what

\SubtaskSolved 

\begin{itemize}
  \item Först deklarerar vi en \code{trait}, \code{CanCompare}, med en generisk typparameter \code{T}. Den innehåller en abstrakt metod \code{compare} som tar två parametrar av typen \code{T} och returnerar en \code{Int}.
  \item Sedan definieras en metod \code{sort} som också tar en generisk typparameter \code{T}. Metoden tar två parametrar, a och b av typen T, samt en \code{using} parameter cc som måste vara en instans av \code{CanCompare[T]}. Inuti metoden används compare-metoden från CanCompare för att bestämma om a och b ska byta plats eller inte. 
  \item När vi försöker köra \code{sort(42, 41)} så får vi felmeddelande av kompilatorn. Anledning till detta är att det inte finns en given instans av CanCompare[Int].
  \item Vi löser detta på nästa rad med \code{given intComparator} som är av typen \linebreak CanCompare[Int]. Vi definierar även vår abstrakta metod \code{compare} från CanCompare med \code{override def compare}... När vi kör \code{sort(42,41)} på nästa rad fungerar det nu som det ska och vi får tillbaka \code{(Int, Int) = (41, 42)}
  \item När vi försöker köra sort med argument av typen \code{Double} får vi ett liknande felmeddelande som vi fick tidigare, och av samma anledning att det inte finns en CanCompare för typen Double.
\end{itemize}

\SubtaskSolved 
\begin{REPL}
scala> given doubleComparator: CanCompare[Double] with
         override def compare(a: Double, b: Double): Int = (a - b).toInt
\end{REPL}

\SubtaskSolved 
\begin{REPL}
scala> given stringComparator: CanCompare[String] with
         override def compare(a: String, b: String): Int = a.compareTo(b)
\end{REPL}

\QUESTEND





\WHAT{Användning av given ordning.}

\QUESTBEGIN

\Task \label{task:implicit-ordering} \what~  Vi ska nu skapa en funktion \code{isSorted} som är generellt användbar genom att göra givna ordningsfunktioner tillgängliga för olika typer. Funktionen  \code{def isSorted(xs: Vector[Int]): Boolean = ???} fungerar bara för samlingar av typen \code{Vector[Int]}.

Om vi i stället använder
\code{def isSorted(xs: Seq[Int]): Boolean = ???} fungerar den för olika samlingar med heltal, även \code{Vector} och \code{List}. 

\Subtask  Testa nedan funktion i REPL med heltalssekvenser av olika typ.
\begin{Code}
def isSorted(xs: Seq[Int]): Boolean = xs == xs.sorted
\end{Code}

\Subtask Det blir problem med nedan försök att göra \code{isSorted} generisk. Hur lyder felmeddelandet? Vad saknas enligt felmeddelandet?
\begin{REPLnonum}
scala> def isSorted[T](xs: Seq[T]): Boolean = xs == xs.sorted
\end{REPLnonum}

\Subtask Vi vill gärna att \code{isSorted} ska fungera för godtyckliga typer T som har en ordningsdefinition. Detta kan göras med nedan funktion där den speciella typparametern \code{[T:Ordering]} betyder att \code{isSorted} är definierad för alla samlingar där typen \code{T} har en given ordning \code{Ordering[T]}. Speciellt gäller detta för alla grundtyperna \code{Int}, \code{Double}, \code{String}, etc., som alla har specifika implementationer av typklassen \code{Ordering}.
\begin{Code}
def isSorted[T:Ordering](xs: Seq[T]): Boolean = xs == xs.sorted
\end{Code}
Testa metoden ovan i REPL enligt nedan.
\begin{REPL}
scala> isSorted(Vector(1,2,3))
scala> isSorted(List(1,2,3,1))
scala> isSorted(Vector("A","B","C"))
scala> isSorted(List("A","B","C","A"))
scala> case class Person(firstName: String, familyName: String)
scala> val persons = Vector(Person("Kim", "Finkodare"), Person("Voldemort","Fulhackare"))
scala> isSorted(persons)
\end{REPL}
Vad ger sista raden för felmeddelande? Varför?


\Subtask \emph{Implicita ordningar.} En typparameter på formen \code{[T:Ordering]} kallas kontextgräns \Eng{context bound} och föranleder kompilatorn att automatiskt expandera funktionshuvudet för \code{isSorted} med en kontextparameter. I stället för att använda \code{[T:Ordering]} kan vi själva lägga till en kontextparameter som motsvarar kontextgränsen. Då får vi också tillgång till ett namn, här nedan \code{ord}, på den implicita ordningen och kan använda det namnet i funktionskroppen och anropa metoder som är medlemmar av typklassen \code{Ordering}. (Namnet på kontextparametern kan också utelämnas, men då får vi istället gå omvägen via inbyggda funktionen \code{summon[T]} för att be kompilatorn leta upp den givna instansen för den typparameter som ges vid anropet.)

\begin{CodeSmall}
def isSorted[T](xs: Seq[T])(using ord: Ordering[T]): Boolean =
  xs.zip(xs.tail).forall(x => ord.lteq(x._1, x._2))
\end{CodeSmall}

Objekt av typen \code{Ordering} har jämförelsemetoder som t.ex. \code{lteq} (förk. \emph{less than or equal}) och \code{gt} (förk. \emph{greater than}).

Det finns givna ordningar för alla grundtyper i standardbiblioteket, alltså t.ex. \code{Ordering[Int]}, \code{Ordering[String]}, etc.
Testa så att kompilatorn hittar ordningen för samlingar med värden av några grundtyper. Kontrollera även enligt nedan att det fortfarande blir problem för egendefinierade klasser, t.ex. \code{Person}  (detta ska vi råda bot på i uppgift \ref{task:custom-ordering}).
\begin{REPL}
scala> isSorted(Vector(1,2,3))
scala> isSorted(Array(1,2,3,1))
scala> isSorted(Vector("A","B","C"))
scala> isSorted(List("A","B","C","A"))
scala> class Person(firstName: String, familyName: String)
scala> val persons = Vector(Person("Kim", "Finkodare"), Person("Robin","Fulhack"))
scala> isSorted(persons)
\end{REPL}

\Subtask \emph{Importera implicita ordningsoperatorer från en \code{Ordering}.} Om man gör import på ett \code{Ordering}-objekt får man tillgång till implicita konverteringar som gör att jämförelseoperatorerna fungerar. Testa nedan variant av \code{isSorted} på olika sekvenstyper och verifiera att \code{<=}, \code{>}, etc., nu fungerar enligt nedan.
\begin{CodeSmall}
def isSorted[T](xs: Seq[T])(using ord: Ordering[T]): Boolean =
  import ord.*
  xs.zip(xs.tail).forall(x => x._1 <= x._2)
\end{CodeSmall}


\SOLUTION

\TaskSolved \what

\SubtaskSolved 
Exempel på tester:
\begin{REPLnonum}
scala> isSorted(Vector(1,2,3))
val res0: Boolean = true

scala> isSorted(Vector(1,2,4,3))
val res1: Boolean = false

scala> isSorted(List(1,2,3))
val res2: Boolean = true

scala> isSorted(List(1,2,4,3))
val res3: Boolean = false
\end{REPLnonum}

\SubtaskSolved 
\begin{REPLnonum}
scala> def isSorted[T](xs: Seq[T]): Boolean = xs == xs.sorted
-- [E172] Type Error: --------------------------------------------------------------------------
1 |def isSorted[T](xs: Seq[T]): Boolean = xs == xs.sorted
  |                                                      ^
  | No implicit Ordering defined for T..
  | I found:
  |
  |     scala.math.Ordering.ordered[T](/* missing */summon[scala.math.Ordering.AsComparable[T]])
  |
  | But no implicit values were found that match type scala.math.Ordering.AsComparable[T].
  |
  | The following import might make progress towards fixing the problem:
  |
  |     import scala.math.Ordered.orderingToOrdered
  |
1 error found
\end{REPLnonum}
Felmeddelandet innebär att kompilatorn inte kan härleda en ordning för den generiska typen \code{T}.

\SubtaskSolved 
\begin{REPLnonum}
scala> isSorted(persons)
-- [E172] Type Error: ------------------------------------------------------------------------------------
1 |isSorted(persons)
  |                 ^
  | No implicit Ordering defined for Person..
  | I found:
  |
  |     scala.math.Ordering.ordered[Person](/* missing */summon[scala.math.Ordering.AsComparable[Person]])
  |
  | But no implicit values were found that match type scala.math.Ordering.AsComparable[Person].
  |
  | The following import might make progress towards fixing the problem:
  |
  |     import scala.math.Ordered.orderingToOrdered
  |
1 error found
\end{REPLnonum}
Felmeddelandet ges därför att kompilatorn inte känner till någon ordning för klassen \code{Person}. 

\SubtaskSolved
-

\SubtaskSolved
-

\QUESTEND






\WHAT{Skapa egen implicit ordning med \code{Ordering}.}

\QUESTBEGIN

\Task \label{task:custom-ordering} \what~

\Subtask Ett sätt att skapa en egen, specialanpassad ordning för dina egna klasser är att mappa dina objekt till typer som redan har en implicit ordning. Med hjälp av metoden \code{by} i objektet \code{scala.math.Ordering} kan man skapa ordningar genom att bifoga en funktion \code{T => S} där \code{T} är typen för de objekt du vill ordna och \code{S} är någon annan typ, t.ex. \code{String} eller \code{Int}, där det redan finns en given ordning.
\begin{REPL}
scala> case class Team(name: String, rank: Int)
scala> val xs =
         Vector(Team("fnatic", 1499), Team("nip", 1473), Team("lumi", 1601))
scala> xs.sorted  // Hur lyder felmeddelandet? Varför blir det fel?
scala> val teamNameOrdering: Ordering[Team] = Ordering.by(t => t.name)
scala> xs.sorted(using teamNameOrdering)   //explicit ordning
scala> given Ordering[Team] = Ordering.by(t => t.rank)
scala> xs.sorted   // Varför funkar det nu?
\end{REPL}

\Subtask Vill man sortera i omvänd ordning kan man använda
\code{Ordering.fromLessThan} som tar en funktion \code{(T, T) => Boolean} vilken ska ge \code{true} om första parametern ska komma före, annars \code{false}. Om vi vill sortera efter \code{rank} i omvänd ordning kan vi göra så här:
\begin{REPL}
scala> val highestRankFirst: Ordering[Team] =
         Ordering.fromLessThan((t1, t2) => t1.rank > t2.rank)
scala> xs.sorted(using highestRankFirst)
\end{REPL}

\Subtask Om du har en case-klass med flera fält och vill ha en fördefinierad implicit sorteringsordning samt \emph{även} erbjuda en alternativ sorteringsordning, så kan du placera en default ordningsdefinition i ett kompanjonsobjekt; detta är nämligen ett av de ställen där kompilatorn söker sist efter eventuella implicita värden innan den ger upp att leta.
\begin{Code}
case class Team(name: String, rank: Int)
object Team:
  given highestRankFirst: Ordering[Team] = 
    Ordering.fromLessThan((t1, t2) => t1.rank > t2.rank)
  val nameOrdering: Ordering[Team] = Ordering.by(t => t.name)
\end{Code}
\begin{REPL}
scala> val xs =
         Vector(Team("fnatic", 1499), Team("nip", 1473), Team("lumi", 1601))
scala> xs.sorted
scala> xs.sorted(Team.nameOrdering)
\end{REPL}



\Subtask Det går också med kompanjonsobjektet ovan att få jämförelseoperatorer att fungera med din case-klass, genom att importera medlemmarna i lämpligt ordningsobjekt. Verifiera att så är fallet enligt nedan:
\begin{REPL}
scala> Team("fnatic",1499) < Team("gurka", 2)  // Vilket fel? Varför?
scala> import Team.highestRankFirst.given
scala> Team("fnatic",1499) < Team("gurka", 2)  // Inget fel? Varför?
\end{REPL}


\SOLUTION

\TaskSolved \what 

\SubtaskSolved
\begin{REPLnonum}
scala> xs.sorted
-- [E172] Type Error: ---------------------------------------------------------------------------------------------------------------
1 |xs.sorted
  |         ^
  | No implicit Ordering defined for Team..
  | I found:
  |
  |     scala.math.Ordering.comparatorToOrdering[Team](/* missing */summon[java.util.Comparator[Team]])
  |
  | But no implicit values were found that match type java.util.Comparator[Team].
  |
  | One of the following imports might make progress towards fixing the problem:
  |
  |     import scala.math.Ordering.comparatorToOrdering
  |     import scala.math.Ordering.ordered
  |
1 error found
\end{REPLnonum}
Felmeddelandet ges därför att kompilatorn inte känner till någon ordning för klassen \code{Team}. 

Efter tilldelningen \code{given Ordering[Team] = Ordering.by(t => t.rank)} existerar en given ordning för \code{Team} i den nuvarande kontexten. 
Därför fungerar nu det efterföljande anropet \code{xs.sorted} som tänkt.

\SubtaskSolved 
-

\SubtaskSolved
-

\SubtaskSolved
\begin{REPLnonum}
scala> Team("fnatic",1499) < Team("gurka", 2)
-- [E008] Not Found Error: ------------------------------------------------------------
1 |Team("fnatic",1499) < Team("gurka", 2)
  |^^^^^^^^^^^^^^^^^^^^^
  |value < is not a member of Team, but could be made available as an extension method.
  |
  |One of the following imports might fix the problem:
  |
  |  import scala.math.Ordered.orderingToOrdered
  |  import scala.math.Ordering.Implicits.infixOrderingOps
  |
1 error found
\end{REPLnonum}
Precis som kompilatorn säger är \code{<} inte en metod definierad för \code{Team}.
Däremot, efter \code{import Team.highestRankFirst.given} importeras även de implicita konverteringar som finns definierade för \code{highestRankFirst: Ordering[Team]} (eftersom det är ett objekt av typen \code{Ordering}).
Därmed fungerar \code{<}. Se uppgift 7e för mer bakgrund.


\QUESTEND






\WHAT{Specialanpassad ordning genom att ärva från \code{Ordered}}

\QUESTBEGIN

\Task  \what~  Om det finns \emph{en} väldefinierad, specifik ordning som man vill ska gälla för sina case-klass-instanser kan man göra den ordnad genom att låta case-klassen mixa in traiten \code{Ordered} och implementera den abstrakta metoden \code{compare}. (Detta illustrerar användning av subtypspolymorfism (d.v.s arv) i stället för ad hoc polymorfism med typklasser.)

\begin{Background}
En trait som används på detta sätt kallas \textbf{gränssnitt} \Eng{interface}, och om man \emph{implementerar} ett gränssnitt så uppfyller man ett ''kontrakt'', som i detta fall innebär att man implementerar det som krävs av ordnade objekt, nämligen att de har en konkret \code{compare}-metod. Du lär dig mer om gränssnitt i kommande kurser.
\end{Background}

\Subtask Implementera case-klassen \code{Team} så att den är en subtyp till \code{Ordered} enligt nedan skiss. Högre rankade lag ska komma före lägre rankade lag. Metoden \code{compare} ska ge ett heltal som är negativt om \code{this} kommer före \code{that}, noll om de ordnas lika, annars positivt.

\begin{Code}
case class Team(name: String, rank: Int) extends Ordered[Team]:
  override def compare(that: Team): Int = ???
\end{Code}
\emph{Tips:} Du kan anropa metoden \code{compare} på alla grundtyper, t.ex. \code{Int}, eftersom de implementerar gränssnittet \code{Ordered}. Genom att negera uttrycket blir ordningen den omvända. 

\begin{REPLnonum}
scala> -(2.compare(1))
\end{REPLnonum}

\Subtask Testa att  din case-klass nu uppfyller det som krävs för att vara ordnad.
\begin{REPLnonum}
scala> Team("fnatic",1499) < Team("gurka", 2)
\end{REPLnonum}


\Subtask Diskutera med handledare eller kursare skillnader och likheter mellan gränssnitt och typklasser, med ledning av denna och föregående uppgifter.
\SOLUTION


\TaskSolved \what

\SubtaskSolved

\begin{Code}
case class Team(name: String, rank: Int) extends Ordered[Team]:
  override def compare(that: Team): Int = -rank.compare(that.rank)
\end{Code}

\SubtaskSolved

\begin{REPLnonum}
scala> Team("fnatic",1499) < Team("gurka", 2)
val res1: Boolean = true
\end{REPLnonum}

\SubtaskSolved
Subtypspolymorfism, alltså användande av arv och gränssnitt \Eng{interface} bygger på att varje subtyp måste implementera vissa medlemmar. 
Kompilatorn kan därmed garantera att \emph{något} kommer att ske vid anrop med en subtyp.
Den kan däremot inte garantera \emph{vad} som kommer att ske. Detta avgörs på plats under körtid,
så kallad dynamisk bindning.

Ad hoc polymorfism å andra sidan bygger på att den anropade funktionen är definierad 
så att den beter sig olika för olika typer. Till detta används någon form av typklasser.
Det är alltså typen som ges vid anrop som avgör vad som sker, 
inte vilket beteende som är definierat i den subtyp som typen ''råkar'' ha.
Redan då koden kompileras kan alltså kompilatorn avgöra vad som kommer att ske baserat på
typen, alltså statisk bindning. Detta innebär att det blir lättare att resonera om
hur programmet beter sig.

\QUESTEND



% \WHAT{Sortering med inbyggda sorteringsmetoder.}

% \QUESTBEGIN

% \Task  \what~  För grundtyperna (\code{Int}, \code{Double}, \code{String}, etc.) finns en fördefinierad ordning som gör så att färdiga sorteringsmetoder fungerar på alla samlingar i \code{scala.collection}. Även jämförelseoperatorerna i uppgift \ref{task:string-order-operators} fungerar enligt den fördefinierade ordningsdefinitionen för alla grundtyper. Denna ordningsdefinition är \textit{implicit tillgänglig} vilket betyder att kompilatorn hittar ordningsdefinitionen utan att vi explicit måste ange den. Detta fungerar i Scala även med primitiva \code{Array}.

% \Subtask Testa metoden \code{sorted} på några olika samlingar. Förklara vad som händer. Hur lyder felmeddelandet på sista raden? Varför blir det fel?

% \begin{REPL}
% scala> Vector(1.1, 4.2, 2.4, 42.0, 9.9).sorted
% scala> val xs = (100000 to 1 by -1).toArray
% scala> xs.sorted
% scala> xs.map(_.toString).sorted
% scala> xs.map(_.toByte).sorted.distinct
% scala> case class Person(firstName: String, familyName: String)
% scala> val ps = Vector(Person("Robin", "Finkodare"), Person("Kim","Fulhack"))
% scala> ps.sorted
% \end{REPL}

% \Subtask Om man har en samling med egendefinierade klasser eller man vill ha en annan sorteringsordning får man definiera ordningen själv. Ett helt generellt sätt att göra detta på  illustreras i uppgift \ref{task:custom-ordering}, men de båda hjälpmetoderna \code{sortWith} och \code{sortBy} räcker i de flesta fall. Hur de används illustreras nedan. Metoden \code{sortBy} kan användas om man tar fram ett värde av grundtyp och är nöjd med den inbyggda sorteringsordningen.

% Metoden \code{sortWith} används om man vill skicka med ett eget jämförelsepredikat som ordnar två element; funktionen ska returnera \code{true} om det första elementet ska vara först, annars \code{false}.

% \begin{REPL}
% scala> case class Person(firstName: String, familyName: String)
% scala> val ps = Vector(Person("Robin", "Finkodare"), Person("Kim","Fulhack"))
% scala> ps.sortBy(_.firstName)
% scala> ps.sortBy(_.familyName)
% scala> ps.sortBy  // tryck TAB två gånger för att se signaturen
% scala> ps.sortWith((p1, p2) => p1.firstName > p2.firstName)
% scala> ps.sortWith  // tryck TAB två gånger för att se signaturen
% scala> Vector(9,5,2,6,9).sortWith((x1, x2) => x1 % 2 > x2 % 2)
% \end{REPL}
% Vad har metoderna \code{sortWith} och \code{sortBy} för signaturer?

% \Subtask Lägg till attributet \code{age: Int} i case-klassen \code{Person} ovan och lägg till fler personer med olika namn och ålder i en vektor och sortera den med \code{sortBy} och \code{sortWith} för olika attribut. Välj själv några olika sätt att sortera på.



% \SOLUTION


% \TaskSolved \what


% \SubtaskSolved
% \begin{enumerate}
% \item Returnerar en sorterad \code{Vector} av \code{double}-värden
% \item Skapar en variabel xs och sparar en \code{Array} med \code{Int}-värden mellan 100000 till 1.
% \item Sorterar \code{xs = 1,2,3...}
% \item Konverterar xs till en \code{Array} av \code{String}-värden och sorterar dem lexikografiskt: \code{xs = "1", "10", "100"} etc.
% \item Konverterar xs till en \code{Array} av \code{Byte}-värden (max 127, min -128) och sorterar dem, samt tar bort dubletter: \code{xs = -128, -127, -1...}
% \item Skapar en ny klass \code{Person} som tar 2 \code{String}-argument i konstruktorn
% \item Sparar en Vector med två \code{Person}-objekt i en variabel ps
% \item Försöker kalla på \code{sorted}-metoden för klassen \code{Person}. Eftersom vi skrivit denna klass själva och inte berättat för Scala hur \code{Person}-objekt ska sorteras, resulterar detta i ett felmeddelande.
% \end{enumerate}

% \SubtaskSolved

% \begin{enumerate}
% \item ---
% \item ---
% \item Sorterar \code{Person}-objekten i ps med avseende på värdet i \code{firstName}
% \item Sorterar \code{Person}-objekten i ps med avseende på värdet i \code{familyName}
% \item \code{sortBy} tar en funktion f som argument. f ska ta ett argument av typen \code{Person} och returnera en generisk typ B.
% \item Sortera \code{Person}-objekten i ps med avseende på \code{firstName} i sjunkande ordning (omvänt från tidigare alltså)
% \item \code{sortWith} tar en funktion lt som argument. lt ska i sin tur ta två argument av typen \code{Person} och returnera ett booleskt värde.
% \item Sorterar en vektor så att värdena som är minst delbara med 2 hamnar först, och de mest delbara med 2 hamnar sist. Detta delar alltså upp udda och jämna tal.
% \end{enumerate}

% \SubtaskSolved
% Klassens signatur blir då:
% \begin{REPLnonum}
% case class Person(firstName: String, lastName: String, age: Int)
% \end{REPLnonum}

% Lägg in dem i en vektor:
% \begin{REPLnonum}
% val ps2 = Vector(Person("a", "asson", 34), Person("asson", "assonson", 1234),
% Person("anna", "Book", 2))
% \end{REPLnonum}

% Sortera dem på olika sätt:
% \begin{enumerate}
% \item
% Vektorn blir sorterad med avseende på personernas ålder i stigande ordning
% \begin{REPLnonum}
% scala> ps2.sortWith((p1, p2) => p1.age < p2.age)
% res40: scala.collection.immutable.Vector[Person] = Vector(Person(anna,Book,2),
% Person(a,asson,34), Person(asson,assonson,1234))
% \end{REPLnonum}

% \item
% Sorterar vektorn med avseende på namn, men också med avseende på ålder (i sjunkande ordning). För att komma före någon i ordningen måste alltså både namnet komma före, och åldern vara högre.
% \begin{REPLnonum}
% scala> ps2.sortWith((p1, p2) => (p1.firstName < p2.firstName) &&
% (p1.age > p2.age))
% res42: scala.collection.immutable.Vector[Person] = Vector(Person(a,asson,34),
% Person(asson,assonson,1234), Person(anna,Book,2))
% \end{REPLnonum}
% \end{enumerate}



% \QUESTEND



